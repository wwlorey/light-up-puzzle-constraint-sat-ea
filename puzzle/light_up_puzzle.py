import copy
import puzzle.coordinate as coord_class
import random
import time


class LightUpPuzzle:
    def __init__(self, config):
        """Initializes the LightUpPuzzle class.

        Where config is a Config object for the light up puzzle problem.
        """

        def generate_coord_boards():
            """Generates a 2D coordinate board and its transpose.

            These are used when verifying solutions and creating random boards.
            """
            self.coord_board = []

            for x in range(self.num_rows):
                coord_list = []
                for y in range(self.num_cols):
                    coord_list.append(coord_class.Coordinate(x, y))

                self.coord_board.append(coord_list)

            self.transpose_coord_board = [list(l) for l in zip(*self.coord_board)]


        def generate_random_board():
            """Randomly generates a solvable board.

            Solvable boards are generated by iteratively placing black squares (with probability
            dictated by the configuration file) and required bulbs around each square. Bulbs
            are also placed randomly around the board (not neighboring black squares). All bulbs are
            then removed, leaving a board with at least one solution.

            This function should only be called in __init__
            """
            self.black_squares = {}
            bulbs = set([])

            if int(self.config.settings["override_random_board_dimensions"]):
                self.num_rows = int(self.config.settings["override_num_rows"])
                self.num_cols = int(self.config.settings["override_num_cols"])

            else:
                min_dimension = int(self.config.settings["min_random_board_dimension"])
                max_dimension = int(self.config.settings["max_random_board_dimension"])

                self.num_rows = random.randint(min_dimension, max_dimension)
                self.num_cols = random.randint(min_dimension, max_dimension)

            generate_coord_boards()

            # Create a list of shuffled coordinates used in assigning black squares & bulbs
            shuffled_coords = []
            for row in self.coord_board:
                for coord in row:
                    shuffled_coords.append(coord)

            random.shuffle(shuffled_coords)

            # Assign black squares & bulbs to the board
            for coord in shuffled_coords:
                if not coord in bulbs: 
                    if random.random() <= float(self.config.settings["black_square_placement_prob"]):
                        # Place a black square
                        adj_coord_list = self.get_adj_coords(coord)
                        num_placed_bulbs = 0

                        # Compute the random max value for this black square
                        max_value = random.choices(list(range(0, int(self.config.settings["adj_value_dont_care"]) + 1)), [int(n) for n in self.config.settings["black_square_value_weights"].split(',')])[0]

                        if max_value == int(self.config.settings["adj_value_dont_care"]):
                            # Always place a black square with value adj_value_dont_care
                            self.black_squares[coord] = max_value
                        
                        else:
                            # Put a placeholder black square to ensure the maximum amount of bulbs can be placed
                            self.black_squares[coord] = int(self.config.settings["adj_value_dont_care"])

                            # Place bulbs around the square, if allowed
                            for adj_coord in adj_coord_list:
                                if num_placed_bulbs < max_value and self.place_bulb(adj_coord, bulbs, allow_cross_shine=False):
                                    num_placed_bulbs += 1

                            # Account for black square placements with value zero
                            if num_placed_bulbs == 0 and len([c for c in self.get_adj_coords(coord) if c in bulbs]):
                                # Place a adj_value_dont_care black square to preserve the bulb placement validity
                                self.black_squares[coord] = int(self.config.settings["adj_value_dont_care"])
                                
                            else:
                                # Update the real black square value to match the number of adjacent bulbs
                                self.black_squares[coord] = num_placed_bulbs
                    
                    elif random.random() <= float(self.config.settings["bulb_placement_prob"]):
                        # Attempt to place a bulb
                        self.place_bulb(coord, bulbs)


        self.black_squares = {}
        self.config = config

        if int(self.config.settings["generate_uniform_random_puzzle"]):
            # Generate random initial board state
            generate_random_board()

        else:
            # Read initial board state
            with open(self.config.settings["input_file_path"], 'r') as input_file:
                # Read line 0 (number of columns)
                self.num_cols = int(input_file.readline())

                # Read line 1 (number of rows)
                self.num_rows = int(input_file.readline())

                # Read line 2 to eof (coordinates of black squares and their adjacency values)
                for row in input_file:
                    black_square_data = [int(i) for i in row.split()]
                    self.black_squares[coord_class.Coordinate(black_square_data[1] - 1, black_square_data[0] - 1)] = black_square_data[2]

            # Generate coordinate versions of the board
            generate_coord_boards()
        
        # Calculate the number of squares that have the possibility of being be lit up
        self.num_possible_lit_cells = self.num_rows * self.num_cols - len(self.black_squares)


    def get_random_coord(self):
        """Returns a random coordinate ranging in the space (num_cols, num_rows)."""
        return coord_class.Coordinate(random.randint(0, self.num_rows - 1), random.randint(0, self.num_cols - 1))


    def get_adj_coords(self, coord):
        """Returns a list of coordinates adjacent to coordinate coord"""
        adj_coords = []

        if not coord.x == 0:
            adj_coords.append(coord_class.Coordinate(coord.x - 1, coord.y))

        if not coord.x == self.num_rows - 1:
            adj_coords.append(coord_class.Coordinate(coord.x + 1, coord.y))

        if not coord.y == 0:
            adj_coords.append(coord_class.Coordinate(coord.x, coord.y - 1))

        if not coord.y == self.num_cols - 1:
            adj_coords.append(coord_class.Coordinate(coord.x, coord.y + 1))

        return adj_coords


    def check_cross_shine(self, coord, bulbs):
        """Returns True if a bulb placed at coord causes cross-shine.
        
        Returns False otherwise (if the bulb is safe to place at coord).
        """
        # Check for cross-shine in the coordinate's row (same x value)
        matching_x_coord_bulbs = [c for c in bulbs if c.x == coord.x]
        num_x_delimeters = 0

        for bulb_coord in matching_x_coord_bulbs:
            min_y = min(bulb_coord.y, coord.y)
            max_y = max(bulb_coord.y, coord.y)

            if max_y - min_y < 2:
                return True

            for black_coord in [c for c in self.black_squares if c.x == coord.x]:
                if black_coord.y < max_y and black_coord.y > min_y:
                    num_x_delimeters += 1

        if num_x_delimeters < len(matching_x_coord_bulbs):
            return True

        # Check for cross-shine in the coordinate's column (same y value)
        matching_y_coord_bulbs = [c for c in bulbs if c.y == coord.y]
        num_y_delimeters = 0

        for bulb_coord in matching_y_coord_bulbs:
            min_x = min(bulb_coord.x, coord.x)
            max_x = max(bulb_coord.x, coord.x)

            if max_x - min_x < 2:
                return True

            for black_coord in [c for c in self.black_squares if c.y == coord.y]:
                if black_coord.x < max_x and black_coord.x > min_x:
                    num_y_delimeters += 1

        if num_y_delimeters < len(matching_y_coord_bulbs):
            return True
        
        return False


    def place_bulb(self, coord, bulbs, allow_cross_shine=True):
        """Attempts to place a bulb at coord position on the board.

        Returns True on success, False on fail.
        """
        if coord in self.black_squares:
            return False # Can't place a bulb on a black square 
        
        if not allow_cross_shine:
            # Check cross shine and placement of bulbs next to zero-valued black square
            if not self.check_cross_shine(coord, bulbs) and len([c for c in self.get_adj_coords(coord) if c in self.black_squares and self.black_squares[c] == 0]) == 0:
                bulbs.add(coord)
                return True

        else:
            bulbs.add(coord)
            return True
        
        return False


    def visualize(self, bulbs=[], print_vis=True):
        """Prints a string representation of the board.

        '_' Empty white square
        'x' Black square (with 0 <= x <= self.config.settings["adj_value_dont_care"])
        '!' Light bulb
        """
        board = [ [ '_' for col in range(self.num_cols) ] for row in range(self.num_rows) ]

        for coord, value in self.black_squares.items():
            board[coord.x][coord.y] = str(value)

        for coord in bulbs:
            board[coord.x][coord.y] = '!'

        vis_str = ''

        for row in board:
            for item in row:
                vis_str += item + ' '

            vis_str += '\n'

        vis_str += '\n'

        if print_vis:
            print(vis_str)

        else:
            return vis_str


    def get_num_bulbs(self, coord_list, bulbs):
        """Returns the number of bulbs in coord_list."""
        num_adj_bulbs = 0

        for coord in coord_list:
            if coord in bulbs:
                num_adj_bulbs += 1

        return num_adj_bulbs


    def get_num_black_squares(self, coord_list):
        """Returns the number of black squares in coord_list."""
        num_adj_black_squares = 0  

        for coord in coord_list:
            if coord in self.black_squares:
                num_adj_black_squares += 1

        return num_adj_black_squares 


    def update_shined_squares(self, genotype):
        """Updates the object's set of shined squares.

        Returns the number of bulbs shining on eachother.
        """
        bulb_on_bulb_shine_count = 0
        self.shined_squares = set([])

        for bulb_coord in genotype.bulbs:
            # Create a list of adjacency lists - used for determining where the bulb shines
            adj_coord_lists = []

            adj_coord_lists.append(self.coord_board[bulb_coord.x][:bulb_coord.y][::-1])           # Row from this column to the left
            adj_coord_lists.append(self.coord_board[bulb_coord.x][bulb_coord.y + 1:])             # Row from this column to the right
            adj_coord_lists.append(self.transpose_coord_board[bulb_coord.y][:bulb_coord.x][::-1]) # Column from this row up
            adj_coord_lists.append(self.transpose_coord_board[bulb_coord.y][bulb_coord.x + 1:])   # Column from this row down

            for coord_list in adj_coord_lists:
                for coord in coord_list:
                    if coord in self.black_squares:
                        break # Shine cannot propagate any further
                    elif coord in genotype.bulbs:
                        # Redundant check for bulb on bulb shining
                        bulb_on_bulb_shine_count += 1
                    else:
                        self.shined_squares.add(coord)

        # Ensure bulbs count as shined squares
        for bulb_coord in genotype.bulbs:
            self.shined_squares.add(bulb_coord)
        
        return bulb_on_bulb_shine_count


    def update_black_square_conditions(self, genotype):
        """Returns the number of invalid black square conditions and the associated
        invalid coordinates.

        Checks against the config file for whether or not to enforce black cell constraints.
        """
        invalid_black_cell_constraint_count = 0
        invalid_black_coords = []

        if int(self.config.settings["enforce_adj_quotas"]):
            for coord, adj_value in self.black_squares.items():
                if adj_value < int(self.config.settings["adj_value_dont_care"]) and self.get_num_bulbs(self.get_adj_coords(coord), genotype.bulbs) != adj_value:
                    invalid_black_cell_constraint_count += abs(adj_value - self.get_num_bulbs(self.get_adj_coords(coord), genotype.bulbs))
                    invalid_black_coords.append(coord)
        
        return invalid_black_cell_constraint_count, invalid_black_coords


    def get_fitness(self, genotype):
        """Updates the given genotype's fitness (number of lit cells / total number of white cells).
        
        For constraint satisfaction fitness function, the fitness is reduced by a factor (penalty_coefficient)
        of the constraints violated seen below in (1) and (2).

        For the fitness repair function, an invalid genotype is repaired to make it valid.

        For the original problem statement fitness function, the fitness is zero if (1) or (2) are not true.
        
        A solution with "good" fitness satisfies these requirements:
        1. No bulbs shine on eachother.
        2. Every black square has the required adjacent bulbs. (can be disabled using config file setting)

        Note: the type of fitness function used is specified in config.
        """
        # Get number of shined squares
        bulb_on_bulb_shine_count = self.update_shined_squares(genotype)
        
        # Get number of black cell constraints violated and the corresponding black cell coordinates 
        invalid_black_cell_constraint_count, invalid_black_coords = self.update_black_square_conditions(genotype)

        # Calculate the genotype's fitness
        genotype.fitness = len(self.shined_squares) / self.num_possible_lit_cells 

        if int(self.config.settings['use_penalty_function']):
            # Use the constraint satisfaction fitness function
            # Penalize the fitness for any validation infringements
            genotype.fitness -= float(self.config.settings['penalty_coefficient']) * (bulb_on_bulb_shine_count + invalid_black_cell_constraint_count) / self.num_possible_lit_cells
        
        elif bulb_on_bulb_shine_count or invalid_black_cell_constraint_count:
            if int(self.config.settings['use_repair_function']):
                # Repair the defective genotype
                for _ in range(int(self.config.settings['repair_retry_count'])):
                    self.repair(genotype, bulb_on_bulb_shine_count, invalid_black_cell_constraint_count, invalid_black_coords)

                    if genotype.fitness != 0:
                        break

            else:
                # Use the original problem statement function
                # Set the fitness to zero because some constraints are invalid
                genotype.fitness = 0


    def place_bulb_randomly(self, bulbs):
        """Attempts to put a bulb randomly on the board in a valid location.

        Stops trying to put a bulb after max_num_random_bulb_placements tries.
        Returns True if successful, False otherwise.
        """
        coord = self.get_random_coord()
        count = 0

        while count < int(self.config.settings["max_num_random_bulb_placements"]) and not self.place_bulb(coord, bulbs):
            coord = self.get_random_coord()
            count += 1

        if count < int(self.config.settings["max_num_random_bulb_placements"]):
            return True

        return False


    def write_to_soln_file(self, bulbs):
        """Writes problem information to the solution file specified in the configuration file."""
        with open(self.config.settings["soln_file_path"], 'w') as soln_file:
            soln_file.write(str(self.num_cols) + '\n')
            soln_file.write(str(self.num_rows) + '\n')

            for coord in sorted(self.black_squares):
                soln_file.write(str(coord.y) + ' ' + str(coord.x) + ' ' + str(self.black_squares[coord]) + '\n')

            soln_file.write(str(len(self.shined_squares)) + '\n')

            for coord in sorted(bulbs):
                soln_file.write(str(coord.y) + ' ' + str(coord.x) + '\n')

            soln_file.write('\n')

    
    def write_to_soln_visualization_file(self, bulbs):
        """Writes solution visualization to file with root name specified in the configuration file."""
        soln_vis_path = self.config.settings["soln_file_path"][:self.config.settings["soln_file_path"].find('.')] + '_visualization.txt'

        with open(soln_vis_path, 'w') as soln_vis_file:
            soln_vis_file.write(self.visualize(bulbs, print_vis=False))


    def repair(self, genotype, bulb_on_bulb_shine_count, invalid_black_cell_constraint_count, invalid_black_coords):
        """Attempts to repair the given genotype to eliminate bulbs shining on eachother and invalid black
        cell constraints.

        If a repair cannot be made, the fitness is set to zero.
        """
        if bulb_on_bulb_shine_count:
            # Remove bulbs until the cross-shine constraint is valid
            tmp_bulbs = copy.deepcopy(genotype.bulbs)
            for b in tmp_bulbs:
                if self.check_cross_shine(b, genotype.bulbs):
                    genotype.bulbs.remove(b)
                    bulb_on_bulb_shine_count -= 2

                    if bulb_on_bulb_shine_count <= 0:
                        break
        
        if invalid_black_cell_constraint_count:
            # Add or remove bulbs around black cells (enforcing the cross-shine constraint) until black cell constraints are met
            for black_coord in invalid_black_coords:
                adj_coords = self.get_adj_coords(black_coord)
                adj_bulb_coords = [c for c in adj_coords if c in genotype.bulbs]
                bulbs_to_add = self.black_squares[black_coord] - len(adj_bulb_coords) 

                if bulbs_to_add > 0:
                    # Add adjacent bulbs
                    num_added_bulbs = 0

                    for coord in adj_coords:
                        if self.place_bulb(coord, genotype.bulbs, allow_cross_shine=False):
                            num_added_bulbs += 1

                            if num_added_bulbs == bulbs_to_add:
                                break

                    # Validate the problem is fixed
                    if num_added_bulbs != bulbs_to_add:
                        genotype.fitness = 0
                        break

                elif bulbs_to_add < 0:
                    # Remove adjacent bulbs
                    bulbs_to_remove = -1 * bulbs_to_add
                    num_removed_bulbs = 0

                    for coord in adj_bulb_coords:
                        genotype.bulbs.remove(coord)
                        num_removed_bulbs += 1

                        if num_removed_bulbs == bulbs_to_remove:
                            break

                    # Validate the problem is fixed
                    if num_removed_bulbs != bulbs_to_remove:
                        genotype.fitness = 0
                        break
        
        # Re-evaluate the fitness
        # Get number of shined squares
        bulb_on_bulb_shine_count = self.update_shined_squares(genotype)
        
        # Get number of black cell constraints violated and the corresponding black cell coordinates 
        invalid_black_cell_constraint_count, invalid_black_coords = self.update_black_square_conditions(genotype)

        # Set the genotype's fitness
        if bulb_on_bulb_shine_count or invalid_black_cell_constraint_count:
            genotype.fitness = 0

        else:
            genotype.fitness = len(self.shined_squares) / self.num_possible_lit_cells 
