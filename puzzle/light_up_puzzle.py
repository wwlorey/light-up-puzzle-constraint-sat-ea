import copy
import puzzle.coordinate as coord_class
import random
import time


class LightUpPuzzle:
    def __init__(self, config):
        """Initializes the LightUpPuzzle class.

        Where config is a Config object for the light up puzzle problem.
        """

        def generate_coord_boards():
            """Generates a 2D coordinate board and its transpose.

            These are used when verifying solutions and creating random boards.
            """
            self.coord_board = []

            for x in range(self.num_rows):
                coord_list = []
                for y in range(self.num_cols):
                    coord_list.append(coord_class.Coordinate(x, y))

                self.coord_board.append(coord_list)

            self.transpose_coord_board = [list(l) for l in zip(*self.coord_board)]


        def generate_random_board():
            """Randomly generates a solvable board.

            Solvable boards are generated by iteratively placing black squares (with probability
            dictated by the configuration file) and required bulbs around each square. Bulbs
            are also placed randomly around the board (not neighboring black squares). All bulbs are
            then removed, leaving a board with at least one solution.

            This function should only be called in __init__
            """
            self.black_squares = {}
            bulbs = set([])

            if int(self.config.settings["override_random_board_dimensions"]):
                self.num_rows = int(self.config.settings["override_num_rows"])
                self.num_cols = int(self.config.settings["override_num_cols"])

            else:
                min_dimension = int(self.config.settings["min_random_board_dimension"])
                max_dimension = int(self.config.settings["max_random_board_dimension"])

                self.num_rows = random.randint(min_dimension, max_dimension)
                self.num_cols = random.randint(min_dimension, max_dimension)

            generate_coord_boards()

            # Create a list of shuffled coordinates used in assigning black squares & bulbs
            shuffled_coords = []
            for row in self.coord_board:
                for coord in row:
                    shuffled_coords.append(coord)

            random.shuffle(shuffled_coords)

            # Assign black squares & bulbs to the board
            for coord in shuffled_coords:
                if not coord in bulbs: 
                    if random.random() <= float(self.config.settings["black_square_placement_prob"]):
                        # Place a black square
                        adj_coord_list = self.get_adj_coords(coord)
                        num_placed_bulbs = 0

                        # Compute the random max value for this black square
                        max_value = random.choices(list(range(0, int(self.config.settings["adj_value_dont_care"]) + 1)), [int(n) for n in self.config.settings["black_square_value_weights"].split(',')])[0]

                        if max_value == int(self.config.settings["adj_value_dont_care"]):
                            # Always place a black square with value adj_value_dont_care
                            self.black_squares[coord] = max_value
                        
                        else:
                            # Put a placeholder black square to ensure the maximum amount of bulbs can be placed
                            self.black_squares[coord] = int(self.config.settings["adj_value_dont_care"])

                            # Place bulbs around the square, if allowed
                            for adj_coord in adj_coord_list:
                                if num_placed_bulbs < max_value and self.place_bulb(adj_coord, bulbs):
                                    num_placed_bulbs += 1

                            # Account for black square placements with value zero
                            if num_placed_bulbs == 0 and len([c for c in self.get_adj_coords(coord) if c in bulbs]):
                                # Place a adj_value_dont_care black square to preserve the bulb placement validity
                                self.black_squares[coord] = int(self.config.settings["adj_value_dont_care"])
                                
                            else:
                                # Update the real black square value to match the number of adjacent bulbs
                                self.black_squares[coord] = num_placed_bulbs
                    
                    elif random.random() <= float(self.config.settings["bulb_placement_prob"]):
                        # Attempt to place a bulb
                        self.place_bulb(coord, bulbs)


        self.black_squares = {}
        self.config = config

        if int(self.config.settings["generate_uniform_random_puzzle"]):
            # Generate random initial board state
            generate_random_board()

        else:
            # Read initial board state
            with open(self.config.settings["input_file_path"], 'r') as input_file:
                # Read line 0 (number of columns)
                self.num_cols = int(input_file.readline())

                # Read line 1 (number of rows)
                self.num_rows = int(input_file.readline())

                # Read line 2 to eof (coordinates of black squares and their adjacency values)
                for row in input_file:
                    black_square_data = [int(i) for i in row.split()]
                    self.black_squares[coord_class.Coordinate(black_square_data[1] - 1, black_square_data[0] - 1)] = black_square_data[2]

            # Generate coordinate versions of the board
            generate_coord_boards()
        
        # Calculate the number of squares that have the possibility of being be lit up
        self.num_possible_lit_cells = self.num_rows * self.num_cols - len(self.black_squares)


    def get_random_coord(self):
        """Returns a random coordinate ranging in the space (num_cols, num_rows)."""
        return coord_class.Coordinate(random.randint(0, self.num_rows - 1), random.randint(0, self.num_cols - 1))


    def get_adj_coords(self, coord):
        """Returns a list of coordinates adjacent to coordinate coord"""
        adj_coords = []

        if not coord.x == 0:
            adj_coords.append(coord_class.Coordinate(coord.x - 1, coord.y))

        if not coord.x == self.num_rows - 1:
            adj_coords.append(coord_class.Coordinate(coord.x + 1, coord.y))

        if not coord.y == 0:
            adj_coords.append(coord_class.Coordinate(coord.x, coord.y - 1))

        if not coord.y == self.num_cols - 1:
            adj_coords.append(coord_class.Coordinate(coord.x, coord.y + 1))

        return adj_coords


    def place_bulb(self, coord, bulbs):
        """Attempts to place a bulb at coord position on the board.

        Returns True on success, False on fail.
        """
        if coord in self.black_squares:
            return False # Can't place a bulb on a black square 

        # Check for cross-shine in the coordinate's row (same x value)
        matching_x_coord_bulbs = [c for c in bulbs if c.x == coord.x]
        num_x_delimeters = 0

        for bulb_coord in matching_x_coord_bulbs:
            min_y = min(bulb_coord.y, coord.y)
            max_y = max(bulb_coord.y, coord.y)

            if max_y - min_y < 2:
                return False

            for black_coord in [c for c in self.black_squares if c.x == coord.x]:
                if black_coord.y < max_y and black_coord.y > min_y:
                    num_x_delimeters += 1

        if num_x_delimeters < len(matching_x_coord_bulbs):
            return False

        # Check for cross-shine in the coordinate's column (same y value)
        matching_y_coord_bulbs = [c for c in bulbs if c.y == coord.y]
        num_y_delimeters = 0

        for bulb_coord in matching_y_coord_bulbs:
            min_x = min(bulb_coord.x, coord.x)
            max_x = max(bulb_coord.x, coord.x)

            if max_x - min_x < 2:
                return False

            for black_coord in [c for c in self.black_squares if c.y == coord.y]:
                if black_coord.x < max_x and black_coord.x > min_x:
                    num_y_delimeters += 1

        if num_y_delimeters < len(matching_y_coord_bulbs):
            return False

        # Check placement of bulbs next to zero-valued black square
        if len([c for c in self.get_adj_coords(coord) if c in self.black_squares and self.black_squares[c] == 0]) == 0:
            bulbs.add(coord)
            return True

        return False


    def visualize(self, bulbs=[]):
        """Prints a string representation of the board.

        '_' Empty white square
        'x' Black square (with 0 <= x <= self.config.settings["adj_value_dont_care"])
        '!' Light bulb
        """
        board = [ [ '_' for col in range(self.num_cols) ] for row in range(self.num_rows) ]

        for coord, value in self.black_squares.items():
            board[coord.x][coord.y] = str(value)

        for coord in bulbs:
            board[coord.x][coord.y] = '!'

        for row in board:
            for item in row:
                print(item + ' ', end='')

            print()

        print()


    def get_num_bulbs(self, coord_list, bulbs):
        """Returns the number of bulbs in coord_list."""
        num_adj_bulbs = 0

        for coord in coord_list:
            if coord in bulbs:
                num_adj_bulbs += 1

        return num_adj_bulbs


    def get_num_black_squares(self, coord_list):
        """Returns the number of black squares in coord_list."""
        num_adj_black_squares = 0  

        for coord in coord_list:
            if coord in self.black_squares:
                num_adj_black_squares += 1

        return num_adj_black_squares 


    def get_fitness(self, bulbs):
        """Returns the puzzle's fitness (number of lit cells / total number of white cells)
        given bulbs (a set of bulb coordinates).
        
        For constraint satisfaction fitness function, the fitness is reduced by a factor (penalty_coefficient)
        if any of (1) or (2) below are not true.

        For the original problem statement fitness function, the fitness is zero if (1) or (2) are not true.
        
        A solution with "good" fitness satisfies these requirements:
        1. No bulbs shine on eachother.
        2. Every black square has the required adjacent bulbs. (can be disabled using config file setting)

        Note: the type of fitness function used can be specified in config.
        """
        # Validity infringement variables
        bulb_on_bulb_shine_count = 0
        invalid_black_cell_constraint_count = 0

        # Create and populate set of shined squares
        self.shined_squares = set([])

        for bulb_coord in bulbs:
            # Create a list of adjacency lists - used for determining where the bulb shines
            adj_coord_lists = []

            adj_coord_lists.append(self.coord_board[bulb_coord.x][:bulb_coord.y][::-1])           # Row from this column to the left
            adj_coord_lists.append(self.coord_board[bulb_coord.x][bulb_coord.y + 1:])             # Row from this column to the right
            adj_coord_lists.append(self.transpose_coord_board[bulb_coord.y][:bulb_coord.x][::-1]) # Column from this row up
            adj_coord_lists.append(self.transpose_coord_board[bulb_coord.y][bulb_coord.x + 1:])   # Column from this row down

            for coord_list in adj_coord_lists:
                for coord in coord_list:
                    if coord in self.black_squares:
                        break # Shine cannot propagate any further
                    elif coord in bulbs:
                        # Redundant check for bulb on bulb shining
                        bulb_on_bulb_shine_count += 1
                    else:
                        self.shined_squares.add(coord)

        # Ensure bulbs count as shined squares
        for bulb_coord in bulbs:
            self.shined_squares.add(bulb_coord)

        # Check black square conditions
        if int(self.config.settings["enforce_adj_quotas"]):
            for coord, adj_value in self.black_squares.items():
                if adj_value < int(self.config.settings["adj_value_dont_care"]) and self.get_num_bulbs(self.get_adj_coords(coord), bulbs) != adj_value:
                    invalid_black_cell_constraint_count += abs(adj_value - self.get_num_bulbs(self.get_adj_coords(coord), bulbs))

        # Calculate and return the fitness
        fitness = len(self.shined_squares) / self.num_possible_lit_cells 

        if int(self.config.settings['use_constraint_sat_fitness_function']):
            # Use the constraint satisfaction fitness function
            # Penalize the fitness for any validation infringements
            fitness -= float(self.config.settings['penalty_coefficient']) * (bulb_on_bulb_shine_count + invalid_black_cell_constraint_count) / self.num_possible_lit_cells

        elif bulb_on_bulb_shine_count or invalid_black_cell_constraint_count:
            # The original problem statement fitness function is being used and some constraints are invalid
            fitness = 0
            
        return fitness


    def place_bulb_randomly(self, bulbs):
        """Attempts to put a bulb randomly on the board in a valid location.

        Stops trying to put a bulb after max_num_random_bulb_placements tries.
        Returns True if successful, False otherwise.
        """
        coord = self.get_random_coord()
        count = 0

        while count < int(self.config.settings["max_num_random_bulb_placements"]) and not self.place_bulb(coord, bulbs):
            coord = self.get_random_coord()
            count += 1

        if count < int(self.config.settings["max_num_random_bulb_placements"]):
            return True

        return False


    def write_to_soln_file(self, bulbs):
        """Writes problem information to the solution file specified in the configuration file."""
        with open(self.config.settings["soln_file_path"], 'w') as soln_file:
            soln_file.write(str(self.num_cols) + '\n')
            soln_file.write(str(self.num_rows) + '\n')

            for coord in sorted(self.black_squares):
                soln_file.write(str(coord.y) + ' ' + str(coord.x) + ' ' + str(self.black_squares[coord]) + '\n')

            soln_file.write(str(len(self.shined_squares)) + '\n')

            for coord in sorted(bulbs):
                soln_file.write(str(coord.y) + ' ' + str(coord.x) + '\n')

            soln_file.write('\n')
